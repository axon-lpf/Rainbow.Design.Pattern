using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using 大话设计模式.备忘录模式;
using 大话设计模式.策略模式;
using 大话设计模式.抽象工厂模式;
using 大话设计模式.代理模式;
using 大话设计模式.迭代器模式;
using 大话设计模式.访问者模式;
using 大话设计模式.工厂方法模式;
using 大话设计模式.工厂模式;
using 大话设计模式.观察者模式;
using 大话设计模式.建造者模式;
using 大话设计模式.解释器模式;
using 大话设计模式.命令模式;
using 大话设计模式.模板方法模式;
using 大话设计模式.桥接模式;
using 大话设计模式.适配器模式;
using 大话设计模式.外观模式;
using 大话设计模式.享元模式;
using 大话设计模式.原型模式;
using 大话设计模式.职责链模式;
using 大话设计模式.中介者模式;
using 大话设计模式.装饰者模式;
using 大话设计模式.状态模式;
using 大话设计模式.组合模式;

namespace 大话设计模式
{
    class Program
    {
        #region  六大原则
        //六大原则：
        //单一职责原则  定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 
        //里氏替换原则  定义：所有引用基类的地方必须能透明地使用其子类的对象。
        //子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
            //1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
            //2.子类中可以增加自己特有的方法。
            //3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
            //4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
        //依赖倒置原则   定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
            //低层模块尽量都要有抽象类或接口，或者两者都有。
            //变量的声明类型尽量是抽象类或接口。
            //使用继承时遵循里氏替换原则。
        //接口隔离原则   定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上
            //接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
            //为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
            //提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
            //运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。
        //迪米特法则    定义：一个对象应该对其他对象保持最少的了解
        //开闭原则      定义： 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
        #endregion
        //创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
        //结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
        //行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。
        static void Main(string[] args)
        {
            #region  工厂方法模式调用
            //            工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
            //在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
            //介绍
            //意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
            //主要解决：主要解决接口选择的问题。
            //何时使用：我们明确地计划不同条件下创建不同实例时。
            //如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
            //关键代码：创建过程在其子类执行。
            //应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。
            //优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。
            //缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
            //使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
            //注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。


            //这里我们使用反射的方式创建对象，替换了之前的工厂类通过switch创建对象的方式，有利于后面的新类型商店增加和算法修改增加和维护
            //以后在项目需求在有变革，我们只需要重新在项目中增加C,D类型商店，继承Ishop实现里面的方法，同时，添加继承IFactroy接口，创建对应的商店对象编译该项目的
            //ProductEnity.dll，以后再进行计算该C,D类型的商店算法就可以通过反射的方式进行计算，不需要修改原来的工程类代码。

            //string shopName = "";  //读取webconfig 商店的名称
            ////第一个ProductEnity是dll的名称，第二个ProductEnity是项目的命名空间。  
            //IFactory af = (IFactory)Assembly.Load("ProductEnity").CreateInstance("ProductEnity." + shopName);
            //Ishop As = af.CreateShop();
            //double total = As.Getrent(30, 50, 3000);
            //Console.WriteLine("该A类型商店的租金为：" + total);

            //Console.WriteLine("=============");
            //IFactory bf = (IFactory)Assembly.Load("ProductEnity").CreateInstance("ProductEnity." + "CreateBshop");
            ////CreateBshop可以保存为配置或者存在数据库中，  
            ////注意该保存字符串应该与项目中创建的类名一样，  
            ////否则反射的方式会找不到该项目下的类。  
            //Ishop Bs = bf.CreateShop(); total = Bs.Getrent(30, 300, 2000); //30 天/100元 日平均绩效为2000  
            //Console.WriteLine("该A类型商店的租金为：" + total);


            //string LiveName = string.Empty;  //需要读取config中名称
            //Factory lF = (Factory)Assembly.Load("LiveEnity").CreateInstance("LiveEnity." + LiveName);
            //Live liv = lF.Create();
            //liv.Action();
            #endregion

            #region 抽象工厂模式的调用
            //抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
            //在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。
            //介绍
            //意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
            //主要解决：主要解决接口选择的问题。
            //何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
            //如何解决：在一个产品族里面，定义多个产品。
            //关键代码：在一个工厂里聚合多个同类产品。
            //应用实例：工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。
            //优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
            //缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。
            //使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。
            //注意事项：产品族难扩展，产品等级易扩展。
            //◊ 同一个产品族的Product在一起使用时，而且它们之间是相互依赖的，不可分离
            //◊ 系统需要由相互关联的多个对象来构成
            //◊ 当想提供一组对象而不显示它们的实现过程，只显示它们的接口
            //◊ 系统不应当依赖一些具体Product类
            IKFCFactory factory = new CheapPackageFactory();
            KFCFood food = factory.CreateFood();
            food.Display();

            KFCDrink drink = factory.CreateDrink();
            drink.Display();
            #endregion

            #region  装饰者模式
            //            装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
            //这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
            //我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。
            //介绍
            //意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
            //主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
            //何时使用：在不想增加很多子类的情况下扩展类。
            //如何解决：将具体功能职责划分，同时继承装饰者模式。
            //关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。
            //应用实例： 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。
            //优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
            //缺点：多层装饰比较复杂。
            //使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。
            //注意事项：可代替继承。

            //另一个类的另一种功能
            ConcreteComponent c = new ConcreteComponent();
            //在原来的基础上去实现它
            ConcreteDecoratorA d1 = new ConcreteDecoratorA();
            ConcreteDecoratorB d2 = new ConcreteDecoratorB();
            d1.SetCompontent(c);
            d2.SetCompontent(d1);
            d2.Operation();

            T50Tank t50 = new T50Tank();
            //给坦克赋予红外线功能
            InfraRed red = new InfraRed(t50);
            //给坦克赋予gps功能
            GPS gps = new GPS(red);
            gps.Shoot();
            #endregion

            #region 装饰者模式与简单工厂模式相结合
            RepCon con = new RepCon();
            //装饰者模式与工厂模式相结合
            IReplaceContent ModelOne = new ReplaceModelOne();
            IReplaceContent ModelTwo = new ReplaceModelTwo();
            RepalceContentModelCombination comOne = new RepalceContentModelCombination(ModelOne);
            RepalceContentModelCombination comTwo = new RepalceContentModelCombination(ModelTwo);
            string result = comOne.RepContent("", con);
            result = comTwo.RepContent(result, con);
            #endregion

            #region  策略模式
            Context cons = new Context(new ConcreteStrategyA());
            cons.AlgorithmInterface();
            #endregion

            #region  代理模式

            //            顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
            //在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
            //介绍
            //意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
            //主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
            //何时使用：在处理消息的时候以过滤很多道。
            //如何解决：拦截的类都实现统一接口。
            //关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。
            //应用实例： 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。
            //优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。
            //缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。
            //使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。
            //注意事项：在 JAVA WEB 中遇到很多应用。
            Proxy pro = new Proxy(new Pursuit(new GirlMM()));
            pro.GiveFlowers();
            pro.GiveDolls();
            pro.GiveChocolate();
            #endregion

            #region 模板方法模式

            //在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。
            //介绍
            //意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
            //主要解决：一些方法通用，却在每一个子类都重新写了这一方法。
            //何时使用：有一些通用的方法。
            //如何解决：将这些通用算法抽象出来。
            //关键代码：在抽象类实现，其他步骤在子类实现。
            //应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、Spirng 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。
            //优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。
            //缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。
            //使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。
            //注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。


            //创建了炒菠菜的实列
            Spinach spinach = new Spinach();
            spinach.CookVegetabel();
            #endregion

            #region 原型模式

            //            原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
            //这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。
            //介绍
            //意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
            //主要解决：在运行期建立和删除原型。
            //何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。
            //如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。
            //关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。
            //应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。
            //优点： 1、性能提高。 2、逃避构造函数的约束。
            //缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。 3、逃避构造函数的约束。
            //使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。

            //注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。
            //原型模式可以适用于以下情形：
            //◊ 当一个系统应该独立于它的产品创建、构成和表示时；
            //◊ 当要实例化的类是在运行时刻指定时，例如通过动态装载来创建一个类；
            //◊ 为了避免创建一个与产品类层次平行的工厂类层次时；
            //◊ 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并Clone它们可能比每次用合适的状态手工实例化该类更方便一些。
            //原型模式具有以下特点：
            //◊ 对客户隐藏了具体的产品类，因此减少了客户知道的名字的数目；
            //◊ 允许客户只通过注册原型实例就可以将一个具体产品类并入到系统中，客户可以在运行时刻建立和删除原型；
            //◊ 减少了子类的构造。原型模式是Clone一个原型而不是请求工厂方法创建一个，所以它不需要一个与具体产品类平行的Creator类层次；
            //◊ 原型模式具有给一个应用软件动态加载新功能的能力。由于Prototype的独立性较高，可以很容易动态加载新功能而不影响旧系统；
            //◊ 产品类不需要非得有任何事先确定的等级结构，因为原型模式适用于任何的等级结构；
            //◊ 原型模式的最重要缺点就是每一个类必须配备一个Clone方法，而且这个Clone方法需要对类的功能进行通盘考虑。这对全新的类来说不是很难，但对已有的类进行改造时，不一定是容易的事。
            ColorManager colormanager = new ColorManager();
            colormanager["red"] = new Color(255, 0, 0);
            colormanager["green"] = new Color(0, 255, 0);
            colormanager["blue"] = new Color(0, 0, 255);

            colormanager["angry"] = new Color(255, 54, 0);
            colormanager["peace"] = new Color(128, 211, 128);
            colormanager["flame"] = new Color(211, 34, 20);

            Color color1 = colormanager["red"].Clone() as Color;
            Color color2 = colormanager["peace"].Clone() as Color;
            Color color3 = colormanager["flame"].Clone() as Color;


            ///浅表克隆原来创建的对象的值会改变
            大话设计模式.原型模式.Person per = new 大话设计模式.原型模式.Person();
            大话设计模式.原型模式.Person p1 = per.Clone() as 大话设计模式.原型模式.Person;
            p1.CurrentEmployee = "liupengfei";
            p1.Member.Id = 3;
            p1.Member.Name = "axiba";

            ///深克隆原来 创建对象的值不会改变
            大话设计模式.原型模式.Person p2 = per.Clone() as 大话设计模式.原型模式.Person;
            大话设计模式.原型模式.Person p3 = SerializeHelper.Derializable<大话设计模式.原型模式.Person>(SerializeHelper.Serializable(p2));
            //或者简写
            // Person p3 = SerializeHelper.DeepClone<Person>(p2);
            p3.Member.Id = 6;
            p3.Member.Name = "how are you";


            //如果当前对象中有引用对象的且引用对象没有进行重写Clone, 对当前对象重新克隆则会改变原来引用对象的值（浅复制） 否则不会改变（深复制）
            //Resume a = new Resume("大鸟");

            //a.SetPersonInfo("男人", "28");

            //a.SetWorkExperience("2015", "宝信软件");

            //Resume b = (Resume)a.Clone();
            //b.SetWorkExperience("2016", "华诚");

            //Resume x = (Resume)a.Clone();

            //x.SetWorkExperience("2017", "未知");

            //a.Display();

            //b.Display();

            //x.Display();
            #endregion

            #region 外观模式
            //外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
            //这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。
            //介绍
            //意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
            //主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
            //何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。
            //如何解决：客户端不与系统耦合，外观类与系统耦合。
            //关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
            //应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。
            //优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。
            //缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
            //使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。
            //注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。


            //外观模式（Facade）的定义:为子系统中的一组接口提供一个一致的界面，用来访问子系统中的一群接口。
            //外观模式实现提供简单的接口（OpenMovie 和 CloseMovie）给客户端，也给客户端和子系统之间实现了解耦
            MovieFacade movie = new MovieFacade();
            Projector pros = new Projector();
            //打开电影
            movie.OpenMovie();
            //调整宽屏幕
            pros.SetWideScreen();
            //调回正常模式
            pros.SetStandardScreen();
            //电影播放完毕 关闭电影
            movie.CloseMovie();
            #endregion

            #region 观察者模式
            //            当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
            //介绍
            //意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
            //主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
            //何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
            //如何解决：使用面向对象技术，可以将这种依赖关系弱化。
            //关键代码：在抽象类里有一个 ArrayList 存放观察者们。
            //应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。
            //优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
            //缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
            //使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。
            //注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

            Blog xmfdsh = new MyBlog("xmfdsh", "发布了一篇新博客");

            // 添加订阅者
            xmfdsh.AddObserver(new Subscriber("王尼玛"));
            xmfdsh.AddObserver(new Subscriber("唐马儒"));
            xmfdsh.AddObserver(new Subscriber("王蜜桃"));
            xmfdsh.AddObserver(new Subscriber("敖尼玛"));
            //更新信息
            xmfdsh.Update();
            //输出结果，此时所有的订阅者都已经得到博客的新消息


            //案例 前台MM 帮员工监视老板 如果老板回来了 通知内部员工赶快工作
            GirlReception girl = new GirlReception();
            NBAObserver nba = new NBAObserver("小刘", girl);
            StockObserver stock = new StockObserver("小王", girl);
            girl.Attach(nba);
            girl.Attach(stock);
            girl.SubjectState = "老杨回来,赶快工作吧";
            girl.Noity();

            //利用了 事件委托的方式
            Gril MM = new Gril();
            Stock sto = new Stock("阿西吧", MM);
            NBA bba = new NBA("大神啊", MM);
            MM.Update += new 观察者模式.EventHandler(sto.CloseStock);
            MM.Update += new 观察者模式.EventHandler(bba.CloseNBA);
            MM.SubjectState = "老杨回来了，赶快工作吧";
            MM.Noity();
            #endregion

            #region 建造者模式
            // 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
            //一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。
            //介绍
            //意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
            //主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
            //何时使用：一些基本部件不会变，而其组合经常变化的时候。
            //如何解决：将变与不变分离开。
            //关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
            //应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。
            //优点： 1、建造者独立，易扩展。 2、便于控制细节风险。
            //缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。
            //使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。
            //注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

            //1、建造者模式不仅内聚性强，而且大大降低耦合度。建造者模式将一个复杂对象的构建与表示分离，并且使得构建代码与表示代码分开，用同样的构建过程创建不同的产品。

            // 2、建造者模式灵活，扩展性强。如果增加新的需求，通过再定义一个建造者类就可以完成，不需要修改原来的代码。

            // 建造者模式主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化
            Director dir = new Director();
            Builder b1 = new ConcreteBuilder1();
            Builder b2 = new ConcreteBuilder2();

            dir.Construct(b1);
            Product _pro = b1.GetResult();
            _pro.Show();
            dir.Construct(b2);
            Product _pros = b2.GetResult();
            _pros.Show();
            #endregion

            #region 适配器模式
            //            适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。
            //这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记 本，这样就可以通过笔记本来读取内存卡。
            //我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。
            //介绍
            //意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
            //主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
            //何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
            //如何解决：继承或依赖（推荐）。
            //关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
            //应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。
            //优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。
            //缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
            //使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
            //注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

            // 对客户端来说，调用的就是Target的Request()
            Target tar = new Adapter();
            tar.Request();

            Player play = new Translator("姚明");
            play.Attactk();
            play.Defense();
            #endregion

            #region 迭代模式

            // 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。
            //迭代器模式属于行为型模式。
            //介绍
            //意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
            //主要解决：不同的方式来遍历整个整合对象。
            //何时使用：遍历一个聚合对象。
            //如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。
            //关键代码：定义接口：hasNext, next。
            //应用实例：JAVA 中的 iterator。
            //优点： 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
            //缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
            //使用场景： 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。
            //注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
            ConcreteAggregate ca = new ConcreteAggregate();
            ca[0] = "小王";
            ca[1] = "小郭";
            ca[2] = "小刘";
            Iterator i = new ConcreteIterator(ca);
            object item = i.First();
            while (!i.IsDone())
            {
                Console.WriteLine("{0}请购买车票", i.CurrentItem());
                i.Next();
            }

            IList<string> axiba = new List<string>();
            axiba.Add("老板");
            axiba.Add("经理");
            axiba.Add("员工");
            IEnumerator<string> e = axiba.GetEnumerator();
            while (e.MoveNext())
            {
                Console.WriteLine("{0}请购买车票", e.Current);
            }
            #endregion

            #region 享元模式
            //            享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。
            //享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。
            //介绍
            //意图：运用共享技术有效地支持大量细粒度的对象。
            //主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
            //何时使用： 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。
            //如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
            //关键代码：用 HashMap 存储这些对象。
            //应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。
            //优点：大大减少对象的创建，降低系统的内存，使效率提高。
            //缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。
            //使用场景： 1、系统有大量相似对象。 2、需要缓冲池的场景。
            //注意事项： 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。

            FlyweightFactory fly = new FlyweightFactory();
            Flyweight fx = fly.GetFlyweight("x");
            fx.Operation(33);
            Flyweight fy = fly.GetFlyweight("y");
            fy.Operation(66);

            UnConcreteFlyweight uf = new UnConcreteFlyweight();
            uf.Operation(88);

            WebSiteFactory website = new WebSiteFactory();
            WebSite web = website.GetWebSiteConceret("产品展示");
            web.Use(new User("小葱"));
            WebSite wb = website.GetWebSiteConceret("产品展示");
            wb.Use(new User("小鸟"));
            WebSite book = website.GetWebSiteConceret("博客");
            web.Use(new User("小葱"));
            WebSite bok = website.GetWebSiteConceret("博客");
            bok.Use(new User("小鸟"));

            #endregion

            #region 状态模式

            //   状态模式
            //在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。
            //在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
            //介绍
            //意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
            //主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。
            //何时使用：代码中包含大量与对象状态有关的条件语句。
            //如何解决：将各种具体的状态类抽象出来。
            //关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。
            //应用实例： 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，'钟是抽象接口','钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。
            //优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
            //缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。
            //使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。
            //注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个

            大话设计模式.状态模式.Light light = new 大话设计模式.状态模式.Light();
            light.PressSwitch();
            light.PressSwitch();
            light.PressSwitch();

            Work works = new Work();
            works.Hour = 9;
            works.WriteProgram();
            #endregion

            #region 备忘录模式

            //            备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
            //介绍
            //意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
            //主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
            //何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有"后悔药"可吃。
            //如何解决：通过一个备忘录类专门存储对象状态。
            //关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。
            //应用实例： 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。
            //优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。
            //缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
            //使用场景： 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。
            //注意事项： 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式
            Originator orig = new Originator();
            orig.State = "ON";
            orig.Show();

            Caretaker care = new Caretaker();
            care.Memneto = orig.CreateMemento();

            orig.State = "OFF";
            orig.Show();

            orig.SetMemento(care.Memneto);
            orig.Show();

            //游戏角色
            GameRole game = new GameRole();
            //创建备份管理者
            MementoManager manager = new MementoManager();
            //大战前备份一下
            manager.Memento = game.SaveGameState();
            //开始大战 没有血了 
            game.Fight();
            //恢复之前的状态
            game.RecoveryState(manager.Memento);
            //重新战斗
            game.Fight();

            game.SaveGameState();
            #endregion

            #region 命令模式
            //命令模式
            //命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
            //介绍
            //意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。
            //主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。
            //何时使用：在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。
            //如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。
            //关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口
            //应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。
            //优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。
            //缺点：使用命令模式可能会导致某些系统有过多的具体命令类。
            //使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。
            //注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。

            //菜单
            Barbecure bar = new Barbecure();
            //使用具体的命令
            Command cmdMutton = new BakefMuttonCommand(bar);
            Command cmdChicken = new BakeChickenWingCommand(bar);
            //服务员记录命令 并且通知
            Waiter waiter = new Waiter();
            waiter.SetOrder(cmdMutton);
            waiter.SetOrder(cmdChicken);
            waiter.Notify();
            #endregion

            #region 桥接模式
            //            桥接模式
            //桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
            //这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。
            //我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。
            //介绍
            //意图：将抽象部分与实现部分分离，使它们都可以独立的变化。
            //主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
            //何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。
            //如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。
            //关键代码：抽象类依赖实现类。
            //应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。
            //优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。
            //缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
            //使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。
            //注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。

            //具体的手机软件
            HandSetSoft gamesoft = new HandSetGame();
            HandSetSoft address = new HandSetAddressList();
            ///手机品牌运行手机软件
            HandSetBrand brandM = new HandSetBrandM(gamesoft);
            brandM.Run();
            HandSetBrand brandN = new HandSetBrandN(address);
            brandN.Run();
            #endregion

            #region  职责链模式
            //责任链模式
            //顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
            //在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
            //介绍
            //意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
            //主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。
            //何时使用：在处理消息的时候以过滤很多道。
            //如何解决：拦截的类都实现统一接口。
            //关键代码：Handler 里面聚合它自己，在 HanleRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。
            //应用实例： 1、红楼梦中的"击鼓传花"。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。
            //优点： 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。
            //缺点： 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。
            //使用场景： 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。
            //注意事项：在 JAVA WEB 中遇到很多应用。
            Manager managerJinli = new CommonManger("小刘");
            Manager managerZongjian = new Majordomo("小刘");
            Manager managers = new GeneralManager("小刘");
            //这里上级完全可以根据实际需求去设置
            managerJinli.SetSuperior(managerZongjian);
            managerZongjian.SetSuperior(managers);
            //请求申请
            Request req = new Request();
            req.RequestContent = "小刘请假";
            req.Number = 1;
            req.RequestType = "请假";
            managerJinli.RequestApplications(req);

            Request req2 = new Request();
            req2.RequestContent = "小刘请假";
            req2.RequestType = "请假";
            req2.Number = 4;
            managerJinli.RequestApplications(req2);
            #endregion

            #region 访问者模式
            //访问者模式
            //在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
            //介绍
            //意图：主要将数据结构与数据操作分离。
            //主要解决：稳定的数据结构和易变的操作耦合问题。
            //何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中。
            //如何解决：在被访问的类里面加一个对外提供接待访问者的接口。
            //关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。
            //应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。
            //优点： 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。
            //缺点： 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
            //使用场景： 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，也不希望在增加新操作时修改这些类。
            //注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。

            ObjectStructurre obj = new ObjectStructurre();
            obj.Attach(new Man());
            obj.Attach(new Woman());
            Success action = new Success();
            Faliling fail = new Faliling();
            obj.Display(action);
            obj.Display(fail);

            Visitor sal = new Salary();
            Emploree man = new 大话设计模式.访问者模式.Managerhua("刘鹏飞");
            man.Accept(sal);

            Emploree cha = new 大话设计模式.访问者模式.Chairman("小郭");
            cha.Accept(sal);
            #endregion

            #region 组合模式
            //  组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。
            //组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。
            //粗粒度对象（Coarse-Grained Object） - 该对象包含以来对象。它有自己的生命周期，也能管理依赖对象的生命周期。
            //依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。
            //策略（Strategies） - 策略表示如何实现组合实体。

            //组合模式
            //组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。
            //这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。
            //我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。
            //介绍
            //意图：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
            //主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。
            //何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。
            //如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。
            //关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。
            //应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。
            //优点： 1、高层模块调用简单。 2、节点自由增加。
            //缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。
            //使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。
            //注意事项：定义时为具体类。
            ConcreteCompany root = new ConcreteCompany("北京总公司");
            root.Add(new HRDepartment("总公司HR部门"));
            root.Add(new FinanceDepartment("总公司财务部"));

            ConcreteCompany shang = new ConcreteCompany("上海华东分公司");
            shang.Add(new HRDepartment("华东HR部门"));
            shang.Add(new FinanceDepartment("华东财务部"));
            root.Add(shang);

            ConcreteCompany comp2 = new ConcreteCompany("南京办公事");
            comp2.Add(new HRDepartment("南京办事处HR部"));
            comp2.Add(new HRDepartment("南京办事处财务部"));
            shang.Add(comp2);

            ConcreteCompany comp3 = new ConcreteCompany("杭州分办事处");
            comp3.Add(new HRDepartment("杭州办事处HR部"));
            comp3.Add(new HRDepartment("杭州办事处财务部"));
            shang.Add(comp3);

            Console.WriteLine("\n 结构图");
            root.Display(1);

            Console.WriteLine("\n 职责");
            root.LineOfDuty();
            #endregion

            #region 中介者模式
            //            中介者模式
            //中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。
            //介绍
            //意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
            //主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。
            //何时使用：多个类相互耦合，形成了网状结构。
            //如何解决：将上述网状结构分离为星型结构。
            //关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。
            //应用实例： 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
            //优点： 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。
            //缺点：中介者会庞大，变得复杂难以维护。
            //使用场景： 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。
            //注意事项：不应当在职责混乱的时候使用。
            ConcreateMediator med = new ConcreateMediator();
            ConcreteColleaguel1 coe1 = new ConcreteColleaguel1(med);
            ConcreteColleaguel2 coe2 = new ConcreteColleaguel2(med);
            med.Con1 = coe1;
            med.Con2 = coe2;
            coe1.Send("您好！我是同事一需要什么帮忙的么");
            coe2.Send("您好！我是同事二需要什么帮忙的么");

            UnitedNationsSecurityCouncil unite = new UnitedNationsSecurityCouncil();

            USA usa = new USA(unite);
            Iraq iraq = new Iraq(unite);
            unite.Iraq = iraq;
            unite.Usa = usa;
            usa.Declare("伊拉克 我要打你个傻逼");
            iraq.Declare("美国 你个傻逼来打我啊！！！");

            #endregion

            #region 解释器模式
            //解释器模式
            //解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
            //介绍
            //意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
            //主要解决：对于一些固定文法构建一个解释句子的解释器。
            //何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
            //如何解决：构件语法树，定义终结符与非终结符。
            //关键代码：构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。
            //应用实例：编译器、运算表达式计算。
            //优点： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。
            //缺点： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。
            //使用场景： 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。
            string chinese = "{数据库}[信息](获取)";
            JContext context = new JContext(chinese);

            List<AbstractExpression> l = new List<AbstractExpression>();
            l.Add(new DatabaseExpression());
            l.Add(new ObjectExpression());
            l.Add(new MethodExpression());

            foreach (AbstractExpression exp in l)
            {
                exp.Interpret(context);
            }
            //Assembly assembly = Assembly.Load("大话设计模式.解释器模式");
            //MethodInfo method = assembly.GetType("大话设计模式.解释器模式." + context.Output.Split('.')[0]).GetMethod(context.Output.Split('.')[1].Replace("()", ""));
            //var obj_J = method.Invoke(null, null) ;
            //List<MessageModel> m = (List<MessageModel>)obj_J;

            Console.WriteLine("中文语法" + chinese);
            Console.WriteLine("解释后的C#代码：" + context.Output);
            // Console.WriteLine("执行结果："+m[0].Message+"  "+m[0].PublishTime);
            #endregion

            Random rand = new Random();
           int index= rand.Next(-1,3);
           Console.WriteLine(index);
            Console.ReadKey();
        }


    }
}
